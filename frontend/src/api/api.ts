/* tslint:disable */
/* eslint-disable */
/**
 * Universal Media Organizer API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    'media_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    'sender_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'updated_at'?: string;
    /**
     * 
     * @type {UserView}
     * @memberof Comment
     */
    'sender'?: UserView;
}
/**
 * 
 * @export
 * @interface CommentAddPost200Response
 */
export interface CommentAddPost200Response {
    /**
     * 
     * @type {string}
     * @memberof CommentAddPost200Response
     */
    'status'?: CommentAddPost200ResponseStatusEnum;
    /**
     * 
     * @type {Comment}
     * @memberof CommentAddPost200Response
     */
    'data'?: Comment;
}

export const CommentAddPost200ResponseStatusEnum = {
    Success: 'success'
} as const;

export type CommentAddPost200ResponseStatusEnum = typeof CommentAddPost200ResponseStatusEnum[keyof typeof CommentAddPost200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface CommentAddPostRequest
 */
export interface CommentAddPostRequest {
    /**
     * 
     * @type {number}
     * @memberof CommentAddPostRequest
     */
    'media_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CommentAddPostRequest
     */
    'content'?: string;
}
/**
 * 
 * @export
 * @interface CommentEditPutRequest
 */
export interface CommentEditPutRequest {
    /**
     * 
     * @type {number}
     * @memberof CommentEditPutRequest
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CommentEditPutRequest
     */
    'content'?: string;
}
/**
 * 
 * @export
 * @interface Filter
 */
export interface Filter {
    /**
     * 
     * @type {string}
     * @memberof Filter
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Filter
     */
    'category'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Filter
     */
    'genres'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Filter
     */
    'year_from'?: number;
    /**
     * 
     * @type {number}
     * @memberof Filter
     */
    'year_to'?: number;
    /**
     * 
     * @type {number}
     * @memberof Filter
     */
    'duration_from'?: number;
    /**
     * 
     * @type {number}
     * @memberof Filter
     */
    'duration_to'?: number;
    /**
     * 
     * @type {number}
     * @memberof Filter
     */
    'rating_from'?: number;
    /**
     * 
     * @type {number}
     * @memberof Filter
     */
    'rating_to'?: number;
}
/**
 * 
 * @export
 * @interface Media
 */
export interface Media {
    /**
     * 
     * @type {number}
     * @memberof Media
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'category'?: string;
    /**
     * 
     * @type {number}
     * @memberof Media
     */
    'cumulative_rating'?: number;
    /**
     * 
     * @type {number}
     * @memberof Media
     */
    'number_of_ratings'?: number;
    /**
     * 
     * @type {number}
     * @memberof Media
     */
    'number_of_tracks'?: number;
    /**
     * 
     * @type {number}
     * @memberof Media
     */
    'release_year'?: number;
    /**
     * 
     * @type {number}
     * @memberof Media
     */
    'duration'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Media
     */
    'genres'?: Array<string>;
    /**
     * 
     * @type {Array<Comment>}
     * @memberof Media
     */
    'comments'?: Array<Comment>;
}
/**
 * 
 * @export
 * @interface MediaAddPostRequest
 */
export interface MediaAddPostRequest {
    /**
     * 
     * @type {string}
     * @memberof MediaAddPostRequest
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaAddPostRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaAddPostRequest
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaAddPostRequest
     */
    'category'?: string;
    /**
     * 
     * @type {number}
     * @memberof MediaAddPostRequest
     */
    'release_year'?: number;
    /**
     * 
     * @type {number}
     * @memberof MediaAddPostRequest
     */
    'duration'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof MediaAddPostRequest
     */
    'genres'?: Array<string>;
}
/**
 * 
 * @export
 * @interface MediaEditPutRequest
 */
export interface MediaEditPutRequest {
    /**
     * 
     * @type {number}
     * @memberof MediaEditPutRequest
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof MediaEditPutRequest
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaEditPutRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaEditPutRequest
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaEditPutRequest
     */
    'category'?: string;
    /**
     * 
     * @type {number}
     * @memberof MediaEditPutRequest
     */
    'release_year'?: number;
    /**
     * 
     * @type {number}
     * @memberof MediaEditPutRequest
     */
    'duration'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof MediaEditPutRequest
     */
    'genres'?: Array<string>;
}
/**
 * 
 * @export
 * @interface MediaLoadIdGet200Response
 */
export interface MediaLoadIdGet200Response {
    /**
     * 
     * @type {string}
     * @memberof MediaLoadIdGet200Response
     */
    'status'?: MediaLoadIdGet200ResponseStatusEnum;
    /**
     * 
     * @type {Media}
     * @memberof MediaLoadIdGet200Response
     */
    'data'?: Media;
}

export const MediaLoadIdGet200ResponseStatusEnum = {
    Success: 'success'
} as const;

export type MediaLoadIdGet200ResponseStatusEnum = typeof MediaLoadIdGet200ResponseStatusEnum[keyof typeof MediaLoadIdGet200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface MediaResult
 */
export interface MediaResult {
    /**
     * 
     * @type {number}
     * @memberof MediaResult
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof MediaResult
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaResult
     */
    'image'?: string;
    /**
     * 
     * @type {number}
     * @memberof MediaResult
     */
    'rating'?: number;
}
/**
 * 
 * @export
 * @interface MediaTrack
 */
export interface MediaTrack {
    /**
     * 
     * @type {number}
     * @memberof MediaTrack
     */
    'user_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof MediaTrack
     */
    'media_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof MediaTrack
     */
    'rating'?: number;
    /**
     * 
     * @type {string}
     * @memberof MediaTrack
     */
    'track_status'?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaTrack
     */
    'media_title'?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaTrack
     */
    'media_category'?: string;
}
/**
 * 
 * @export
 * @interface SearchPost200Response
 */
export interface SearchPost200Response {
    /**
     * 
     * @type {string}
     * @memberof SearchPost200Response
     */
    'status'?: SearchPost200ResponseStatusEnum;
    /**
     * 
     * @type {Array<MediaResult>}
     * @memberof SearchPost200Response
     */
    'data'?: Array<MediaResult>;
}

export const SearchPost200ResponseStatusEnum = {
    Success: 'success'
} as const;

export type SearchPost200ResponseStatusEnum = typeof SearchPost200ResponseStatusEnum[keyof typeof SearchPost200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface TrackAddPost200Response
 */
export interface TrackAddPost200Response {
    /**
     * 
     * @type {string}
     * @memberof TrackAddPost200Response
     */
    'status'?: TrackAddPost200ResponseStatusEnum;
    /**
     * 
     * @type {MediaTrack}
     * @memberof TrackAddPost200Response
     */
    'data'?: MediaTrack;
}

export const TrackAddPost200ResponseStatusEnum = {
    Success: 'success'
} as const;

export type TrackAddPost200ResponseStatusEnum = typeof TrackAddPost200ResponseStatusEnum[keyof typeof TrackAddPost200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface TrackAddPostRequest
 */
export interface TrackAddPostRequest {
    /**
     * 
     * @type {number}
     * @memberof TrackAddPostRequest
     */
    'media_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof TrackAddPostRequest
     */
    'rating'?: number;
    /**
     * 
     * @type {string}
     * @memberof TrackAddPostRequest
     */
    'track_status'?: string;
}
/**
 * 
 * @export
 * @interface UserEditPut200Response
 */
export interface UserEditPut200Response {
    /**
     * 
     * @type {string}
     * @memberof UserEditPut200Response
     */
    'status'?: UserEditPut200ResponseStatusEnum;
    /**
     * 
     * @type {UserView}
     * @memberof UserEditPut200Response
     */
    'data'?: UserView;
}

export const UserEditPut200ResponseStatusEnum = {
    Success: 'success'
} as const;

export type UserEditPut200ResponseStatusEnum = typeof UserEditPut200ResponseStatusEnum[keyof typeof UserEditPut200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface UserEditPutRequest
 */
export interface UserEditPutRequest {
    /**
     * 
     * @type {string}
     * @memberof UserEditPutRequest
     */
    'fullname'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserEditPutRequest
     */
    'avatar'?: string;
}
/**
 * 
 * @export
 * @interface UserInfo
 */
export interface UserInfo {
    /**
     * 
     * @type {number}
     * @memberof UserInfo
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'login'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'fullname'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'avatar'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'last_login_at'?: string;
    /**
     * 
     * @type {Array<MediaTrack>}
     * @memberof UserInfo
     */
    'tracks'?: Array<MediaTrack>;
}
/**
 * 
 * @export
 * @interface UserLogin
 */
export interface UserLogin {
    /**
     * 
     * @type {string}
     * @memberof UserLogin
     */
    'login'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLogin
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface UserLogoutPost200Response
 */
export interface UserLogoutPost200Response {
    /**
     * 
     * @type {string}
     * @memberof UserLogoutPost200Response
     */
    'status'?: UserLogoutPost200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UserLogoutPost200Response
     */
    'data'?: string;
}

export const UserLogoutPost200ResponseStatusEnum = {
    Success: 'success'
} as const;

export type UserLogoutPost200ResponseStatusEnum = typeof UserLogoutPost200ResponseStatusEnum[keyof typeof UserLogoutPost200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface UserRegister
 */
export interface UserRegister {
    /**
     * 
     * @type {string}
     * @memberof UserRegister
     */
    'login'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRegister
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRegister
     */
    'fullname'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRegister
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface UserRegisterPost200Response
 */
export interface UserRegisterPost200Response {
    /**
     * 
     * @type {string}
     * @memberof UserRegisterPost200Response
     */
    'status'?: UserRegisterPost200ResponseStatusEnum;
    /**
     * 
     * @type {UserInfo}
     * @memberof UserRegisterPost200Response
     */
    'data'?: UserInfo;
}

export const UserRegisterPost200ResponseStatusEnum = {
    Success: 'success'
} as const;

export type UserRegisterPost200ResponseStatusEnum = typeof UserRegisterPost200ResponseStatusEnum[keyof typeof UserRegisterPost200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface UserRegisterPost400Response
 */
export interface UserRegisterPost400Response {
    /**
     * 
     * @type {string}
     * @memberof UserRegisterPost400Response
     */
    'status'?: UserRegisterPost400ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UserRegisterPost400Response
     */
    'message'?: string;
}

export const UserRegisterPost400ResponseStatusEnum = {
    Error: 'error'
} as const;

export type UserRegisterPost400ResponseStatusEnum = typeof UserRegisterPost400ResponseStatusEnum[keyof typeof UserRegisterPost400ResponseStatusEnum];

/**
 * 
 * @export
 * @interface UserView
 */
export interface UserView {
    /**
     * 
     * @type {number}
     * @memberof UserView
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserView
     */
    'login'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserView
     */
    'fullname'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserView
     */
    'avatar'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserView
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserView
     */
    'last_login_at'?: string;
}

/**
 * CommentApi - axios parameter creator
 * @export
 */
export const CommentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add comment
         * @param {CommentAddPostRequest} commentAddPostRequest Comment information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentAddPost: async (commentAddPostRequest: CommentAddPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentAddPostRequest' is not null or undefined
            assertParamExists('commentAddPost', 'commentAddPostRequest', commentAddPostRequest)
            const localVarPath = `/comment/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commentAddPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete comment
         * @param {number} id Comment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentDeleteIdDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('commentDeleteIdDelete', 'id', id)
            const localVarPath = `/comment/delete/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit comment
         * @param {CommentEditPutRequest} commentEditPutRequest Comment information to edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentEditPut: async (commentEditPutRequest: CommentEditPutRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentEditPutRequest' is not null or undefined
            assertParamExists('commentEditPut', 'commentEditPutRequest', commentEditPutRequest)
            const localVarPath = `/comment/edit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commentEditPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommentApi - functional programming interface
 * @export
 */
export const CommentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add comment
         * @param {CommentAddPostRequest} commentAddPostRequest Comment information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commentAddPost(commentAddPostRequest: CommentAddPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommentAddPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commentAddPost(commentAddPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete comment
         * @param {number} id Comment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commentDeleteIdDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLogoutPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commentDeleteIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit comment
         * @param {CommentEditPutRequest} commentEditPutRequest Comment information to edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commentEditPut(commentEditPutRequest: CommentEditPutRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommentAddPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commentEditPut(commentEditPutRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CommentApi - factory interface
 * @export
 */
export const CommentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommentApiFp(configuration)
    return {
        /**
         * 
         * @summary Add comment
         * @param {CommentAddPostRequest} commentAddPostRequest Comment information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentAddPost(commentAddPostRequest: CommentAddPostRequest, options?: any): AxiosPromise<CommentAddPost200Response> {
            return localVarFp.commentAddPost(commentAddPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete comment
         * @param {number} id Comment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentDeleteIdDelete(id: number, options?: any): AxiosPromise<UserLogoutPost200Response> {
            return localVarFp.commentDeleteIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit comment
         * @param {CommentEditPutRequest} commentEditPutRequest Comment information to edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentEditPut(commentEditPutRequest: CommentEditPutRequest, options?: any): AxiosPromise<CommentAddPost200Response> {
            return localVarFp.commentEditPut(commentEditPutRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommentApi - object-oriented interface
 * @export
 * @class CommentApi
 * @extends {BaseAPI}
 */
export class CommentApi extends BaseAPI {
    /**
     * 
     * @summary Add comment
     * @param {CommentAddPostRequest} commentAddPostRequest Comment information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentApi
     */
    public commentAddPost(commentAddPostRequest: CommentAddPostRequest, options?: AxiosRequestConfig) {
        return CommentApiFp(this.configuration).commentAddPost(commentAddPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete comment
     * @param {number} id Comment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentApi
     */
    public commentDeleteIdDelete(id: number, options?: AxiosRequestConfig) {
        return CommentApiFp(this.configuration).commentDeleteIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit comment
     * @param {CommentEditPutRequest} commentEditPutRequest Comment information to edit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentApi
     */
    public commentEditPut(commentEditPutRequest: CommentEditPutRequest, options?: AxiosRequestConfig) {
        return CommentApiFp(this.configuration).commentEditPut(commentEditPutRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MediaApi - axios parameter creator
 * @export
 */
export const MediaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add media
         * @param {MediaAddPostRequest} mediaAddPostRequest Media information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaAddPost: async (mediaAddPostRequest: MediaAddPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaAddPostRequest' is not null or undefined
            assertParamExists('mediaAddPost', 'mediaAddPostRequest', mediaAddPostRequest)
            const localVarPath = `/media/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mediaAddPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete media
         * @param {number} id Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaDeleteIdDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mediaDeleteIdDelete', 'id', id)
            const localVarPath = `/media/delete/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit media
         * @param {MediaEditPutRequest} mediaEditPutRequest Media information to edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaEditPut: async (mediaEditPutRequest: MediaEditPutRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaEditPutRequest' is not null or undefined
            assertParamExists('mediaEditPut', 'mediaEditPutRequest', mediaEditPutRequest)
            const localVarPath = `/media/edit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mediaEditPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get media info
         * @param {number} id Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaLoadIdGet: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mediaLoadIdGet', 'id', id)
            const localVarPath = `/media/load/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search media
         * @param {Filter} filter Search filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPost: async (filter: Filter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('searchPost', 'filter', filter)
            const localVarPath = `/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaApi - functional programming interface
 * @export
 */
export const MediaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MediaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add media
         * @param {MediaAddPostRequest} mediaAddPostRequest Media information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaAddPost(mediaAddPostRequest: MediaAddPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaLoadIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaAddPost(mediaAddPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete media
         * @param {number} id Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaDeleteIdDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLogoutPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaDeleteIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit media
         * @param {MediaEditPutRequest} mediaEditPutRequest Media information to edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaEditPut(mediaEditPutRequest: MediaEditPutRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaLoadIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaEditPut(mediaEditPutRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get media info
         * @param {number} id Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaLoadIdGet(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaLoadIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaLoadIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search media
         * @param {Filter} filter Search filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPost(filter: Filter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPost(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MediaApi - factory interface
 * @export
 */
export const MediaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MediaApiFp(configuration)
    return {
        /**
         * 
         * @summary Add media
         * @param {MediaAddPostRequest} mediaAddPostRequest Media information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaAddPost(mediaAddPostRequest: MediaAddPostRequest, options?: any): AxiosPromise<MediaLoadIdGet200Response> {
            return localVarFp.mediaAddPost(mediaAddPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete media
         * @param {number} id Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaDeleteIdDelete(id: number, options?: any): AxiosPromise<UserLogoutPost200Response> {
            return localVarFp.mediaDeleteIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit media
         * @param {MediaEditPutRequest} mediaEditPutRequest Media information to edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaEditPut(mediaEditPutRequest: MediaEditPutRequest, options?: any): AxiosPromise<MediaLoadIdGet200Response> {
            return localVarFp.mediaEditPut(mediaEditPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get media info
         * @param {number} id Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaLoadIdGet(id: number, options?: any): AxiosPromise<MediaLoadIdGet200Response> {
            return localVarFp.mediaLoadIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search media
         * @param {Filter} filter Search filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPost(filter: Filter, options?: any): AxiosPromise<SearchPost200Response> {
            return localVarFp.searchPost(filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MediaApi - object-oriented interface
 * @export
 * @class MediaApi
 * @extends {BaseAPI}
 */
export class MediaApi extends BaseAPI {
    /**
     * 
     * @summary Add media
     * @param {MediaAddPostRequest} mediaAddPostRequest Media information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public mediaAddPost(mediaAddPostRequest: MediaAddPostRequest, options?: AxiosRequestConfig) {
        return MediaApiFp(this.configuration).mediaAddPost(mediaAddPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete media
     * @param {number} id Media ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public mediaDeleteIdDelete(id: number, options?: AxiosRequestConfig) {
        return MediaApiFp(this.configuration).mediaDeleteIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit media
     * @param {MediaEditPutRequest} mediaEditPutRequest Media information to edit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public mediaEditPut(mediaEditPutRequest: MediaEditPutRequest, options?: AxiosRequestConfig) {
        return MediaApiFp(this.configuration).mediaEditPut(mediaEditPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get media info
     * @param {number} id Media ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public mediaLoadIdGet(id: number, options?: AxiosRequestConfig) {
        return MediaApiFp(this.configuration).mediaLoadIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search media
     * @param {Filter} filter Search filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public searchPost(filter: Filter, options?: AxiosRequestConfig) {
        return MediaApiFp(this.configuration).searchPost(filter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TrackApi - axios parameter creator
 * @export
 */
export const TrackApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add track
         * @param {TrackAddPostRequest} trackAddPostRequest Track information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackAddPost: async (trackAddPostRequest: TrackAddPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackAddPostRequest' is not null or undefined
            assertParamExists('trackAddPost', 'trackAddPostRequest', trackAddPostRequest)
            const localVarPath = `/track/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trackAddPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete track
         * @param {number} id Track ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackDeleteIdDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('trackDeleteIdDelete', 'id', id)
            const localVarPath = `/track/delete/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit track
         * @param {TrackAddPostRequest} trackAddPostRequest Track information to edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackEditPut: async (trackAddPostRequest: TrackAddPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackAddPostRequest' is not null or undefined
            assertParamExists('trackEditPut', 'trackAddPostRequest', trackAddPostRequest)
            const localVarPath = `/track/edit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trackAddPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrackApi - functional programming interface
 * @export
 */
export const TrackApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TrackApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add track
         * @param {TrackAddPostRequest} trackAddPostRequest Track information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackAddPost(trackAddPostRequest: TrackAddPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackAddPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackAddPost(trackAddPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete track
         * @param {number} id Track ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackDeleteIdDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLogoutPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackDeleteIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit track
         * @param {TrackAddPostRequest} trackAddPostRequest Track information to edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackEditPut(trackAddPostRequest: TrackAddPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackAddPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackEditPut(trackAddPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TrackApi - factory interface
 * @export
 */
export const TrackApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TrackApiFp(configuration)
    return {
        /**
         * 
         * @summary Add track
         * @param {TrackAddPostRequest} trackAddPostRequest Track information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackAddPost(trackAddPostRequest: TrackAddPostRequest, options?: any): AxiosPromise<TrackAddPost200Response> {
            return localVarFp.trackAddPost(trackAddPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete track
         * @param {number} id Track ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackDeleteIdDelete(id: number, options?: any): AxiosPromise<UserLogoutPost200Response> {
            return localVarFp.trackDeleteIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit track
         * @param {TrackAddPostRequest} trackAddPostRequest Track information to edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackEditPut(trackAddPostRequest: TrackAddPostRequest, options?: any): AxiosPromise<TrackAddPost200Response> {
            return localVarFp.trackEditPut(trackAddPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TrackApi - object-oriented interface
 * @export
 * @class TrackApi
 * @extends {BaseAPI}
 */
export class TrackApi extends BaseAPI {
    /**
     * 
     * @summary Add track
     * @param {TrackAddPostRequest} trackAddPostRequest Track information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackApi
     */
    public trackAddPost(trackAddPostRequest: TrackAddPostRequest, options?: AxiosRequestConfig) {
        return TrackApiFp(this.configuration).trackAddPost(trackAddPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete track
     * @param {number} id Track ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackApi
     */
    public trackDeleteIdDelete(id: number, options?: AxiosRequestConfig) {
        return TrackApiFp(this.configuration).trackDeleteIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit track
     * @param {TrackAddPostRequest} trackAddPostRequest Track information to edit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackApi
     */
    public trackEditPut(trackAddPostRequest: TrackAddPostRequest, options?: AxiosRequestConfig) {
        return TrackApiFp(this.configuration).trackEditPut(trackAddPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Edit user
         * @param {UserEditPutRequest} userEditPutRequest User information to edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEditPut: async (userEditPutRequest: UserEditPutRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userEditPutRequest' is not null or undefined
            assertParamExists('userEditPut', 'userEditPutRequest', userEditPutRequest)
            const localVarPath = `/user/edit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userEditPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user info
         * @param {string} login User login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoadLoginGet: async (login: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'login' is not null or undefined
            assertParamExists('userLoadLoginGet', 'login', login)
            const localVarPath = `/user/load/{login}`
                .replace(`{${"login"}}`, encodeURIComponent(String(login)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login user
         * @param {UserLogin} userLogin User credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginPost: async (userLogin: UserLogin, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userLogin' is not null or undefined
            assertParamExists('userLoginPost', 'userLogin', userLogin)
            const localVarPath = `/user/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userLogin, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogoutPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register user
         * @param {UserRegister} userRegister User credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRegisterPost: async (userRegister: UserRegister, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userRegister' is not null or undefined
            assertParamExists('userRegisterPost', 'userRegister', userRegister)
            const localVarPath = `/user/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRegister, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Edit user
         * @param {UserEditPutRequest} userEditPutRequest User information to edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userEditPut(userEditPutRequest: UserEditPutRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserEditPut200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userEditPut(userEditPutRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get user info
         * @param {string} login User login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userLoadLoginGet(login: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRegisterPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userLoadLoginGet(login, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Login user
         * @param {UserLogin} userLogin User credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userLoginPost(userLogin: UserLogin, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRegisterPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userLoginPost(userLogin, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Logout user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userLogoutPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLogoutPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userLogoutPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register user
         * @param {UserRegister} userRegister User credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userRegisterPost(userRegister: UserRegister, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRegisterPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userRegisterPost(userRegister, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Edit user
         * @param {UserEditPutRequest} userEditPutRequest User information to edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEditPut(userEditPutRequest: UserEditPutRequest, options?: any): AxiosPromise<UserEditPut200Response> {
            return localVarFp.userEditPut(userEditPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user info
         * @param {string} login User login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoadLoginGet(login: string, options?: any): AxiosPromise<UserRegisterPost200Response> {
            return localVarFp.userLoadLoginGet(login, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login user
         * @param {UserLogin} userLogin User credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginPost(userLogin: UserLogin, options?: any): AxiosPromise<UserRegisterPost200Response> {
            return localVarFp.userLoginPost(userLogin, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogoutPost(options?: any): AxiosPromise<UserLogoutPost200Response> {
            return localVarFp.userLogoutPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register user
         * @param {UserRegister} userRegister User credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRegisterPost(userRegister: UserRegister, options?: any): AxiosPromise<UserRegisterPost200Response> {
            return localVarFp.userRegisterPost(userRegister, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Edit user
     * @param {UserEditPutRequest} userEditPutRequest User information to edit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userEditPut(userEditPutRequest: UserEditPutRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userEditPut(userEditPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user info
     * @param {string} login User login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userLoadLoginGet(login: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userLoadLoginGet(login, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login user
     * @param {UserLogin} userLogin User credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userLoginPost(userLogin: UserLogin, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userLoginPost(userLogin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userLogoutPost(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userLogoutPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register user
     * @param {UserRegister} userRegister User credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userRegisterPost(userRegister: UserRegister, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userRegisterPost(userRegister, options).then((request) => request(this.axios, this.basePath));
    }
}


